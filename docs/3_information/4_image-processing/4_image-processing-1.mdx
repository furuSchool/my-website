---
title : 4. 画像処理 (画像 → 画像)
---

:::warning[目標]
画像 $\rightarrow$ 画像の処理を行う手法を色々知る。
:::

---
## 空間フィルタリング
空間領域での画像処理手法。イメージ通りにそのまま画像にフィルターをかければいい。
### 線形フィルタ
:::tip[線形フィルタ]
入力画像 $f(i,j)$ に対して，出力画像 $g(i,j) = \sum_{n = - W}^{W} \sum_{m = - W}^{W} h(n,m) f(i+n,j+m)$

- $h(n,m)$ がフィルタ（カーネル）の係数を表し，その大きさは $(2W+1) \times (2W+1)$
- 変換したい画素にプラスして，周囲の画素も重みをかけて足し合わせる（畳み込み）
:::
- 線形フィルタ以外は全て非線形フィルタ
- 線形フィルタは定常信号の処理に使われる
- CONVnet（CNN）は，この重みをバックプロパゲーション（誤差逆伝播法）で自由に変える

### 平滑化フィルタ
画像のノイズ除去や濃淡変動の軽減に使われる。
- 平均化フィルタ：周囲の画素の平均値を取る
- 加重平均化フィルタ：周囲の画素の重み付き平均値を取る
- ガウシアンフィルタ：周囲の画素のガウス分布に基づく重み付き平均値を取る

### エッジ抽出フィルタ
エッジ = 画像の濃淡変化が急激な部分 を抽出する。図形や特徴を検出するのに使われる。
- 微分フィルタ：微分 = 差分を取る。
    - 一次微分 $\begin{bmatrix} 0 & 0 & 0 \\ 0 & -1 & 1 \\ 0 & 0 & 0 \end{bmatrix},~ \begin{bmatrix} 0 & 0 & 0 \\ 0 & -1 & 0 \\ 0 & 1 & 0 \end{bmatrix}
    , ~\begin{bmatrix} 0 & 0 & 0 \\ -\frac{1}{2} & 0 & \frac{1}{2} \\ 0 & 0 & 0 \end{bmatrix}$ など
    - 二次微分 $\begin{bmatrix} 0 & 0 & 0 \\ 1 & -2 & 1 \\ 0 & 0 & 0 \end{bmatrix}$ など
    - ラプラシアンフィルタ $\begin{bmatrix} 0 & 1 & 0 \\ 1 & -4 & 1 \\ 0 & 1 & 0 \end{bmatrix}$
- LoGフィルタ：ガウシアンフィルタをかけてノイズを除去した後にラプラシアンフィルタをかける
    - 微分フィルタはノイズを強調するため
    - 人間もこのフィルターを持っている
    - $\sigma$ で低域通過特性を制御できる
    - ただし，計算コストが高い
- DoGフィルタ：LoGフィルタの近似。異なる $\sigma$ のガウシアンフィルタをかけて差分を取る
    - $\sigma$ を大きくするのと画像を縮小するのは同じ効果があるらしい
- ソーベルフィルタ：微分 + 平滑化
    - $\begin{bmatrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{bmatrix}$ など

:::warning[エッジ検出]
エッジ検出には，フィルタリングに加えて，方向性の検出，極大値判定，2重の閾値処理，接続性の判定等を含む Canny Edge Detector などがある。
:::

### メディアンフィルタ
周囲の画素の中央値を取る。ごま塩ノイズ，スパイクノイズの除去に効果が大きい

### エッジ保存平滑化フィルタ
例えば，9 通りのフィルタを用意し，そのうち最も分散が小さくなるフィルタを選択して平滑化を行う。

#### バイラテラルフィルタ
周囲の画素を（距離のガウシアン）ｘ（輝度差のガウシアン）での重みづけ和をとる。
- 平均化フィルタと異なり，色の大幅な変化はそのままにノイズの除去ができる（エッジがなまらない）

#### Joint Bilateral Filter
別の参照画像を画素値距離の重みづけに利用して，参照画像に基づいたエッジ保存平滑化を行う。

#### ノンローカルミーンフィルター
画像全体の類似度に基づき，類似度が高いほど重みを大きくして平均値を取る。

#### BM3D filter
類似ブロックをまとめて三次元にしてフィルタリングを行い，元の画像に戻して重み付き平均で画像を再構成する。結構使われる。

---
## 周波数フィルタリング
周波数領域でフィルタリングする際は，2 次元 DFT を用いる。
- 画像の周波数：画像の濃淡変化の速さ。周波数が高いと濃淡変化が激しい（ = 縞模様が多い）
- 周波数領域は，二次元の白黒のグラフとして表現される。中心が低周波，周囲が高周波で，白いほどその周波数の成分が多い
- 空間フィルタの大きさが大きいほど，周波数フィルタの方が有利になる
    - 周波数領域で急峻 = 空間領域で広い

<div style={{ display: 'flex', justifyContent: 'left', gap: '20px' }}>
  <img src="/img/information/image_fourier_before.png" style={{ width: '50%' }} />
  <img src="/img/information/image_fourier_after.png" style={{ width: '50%' }} />
</div>
画像は[画像処理工学](http://imgprolab.sys.fit.ac.jp/~yama/imgproc/lec/imgproc_imgfreq_texture_2018.pdf)より引用

### ローパスフィルタ
- 平滑化される。エッジがぼやける
- 方形フィルタ，ガウシアンフィルタなどがある

### ハイパスフィルタ
- エッジが強調される。ノイズが強調される
- 滑らかな変化がなくなり，そこは黒くなってしまう

他にも，バンドパスフィルタ，高域強調フィルタなどがある。

---
## 画像の復元・再構成

:::warning[目標]
復元：ボケ（焦点ボケ，動きボケ，大気乱流等での劣化）などの劣化からの画像修復処理  
再構成：部分データを集めて画像を構築する処理（CTなど）
:::

### 画像劣化モデル
:::tip[画像劣化モデル]
$h$ （点広がり関数）という画像の劣化を表す関数の畳み込み + ノイズ $n$ が加わると考える。  
- 出力画像：$g(x,y) = f(x,y) \ast h(x,y) + n(x,y) = \int \int f(x-u, y-v) h(u,v) du dv + n(x,y)$  
- 周波数領域だと，$G(u,v) = F(u,v)H(u,v) + N(u,v)$
:::
- 理想的には，点広がり関数 $h$ はデルタ関数であるが，ガウス関数や平均値フィルタなども適用される
- 点広がり関数 $h$ は画面内で変化のない線形フィルタを想定することが多い（が，例えば前景と後景だと本当は違うはず）

### 復元
単純には，$H$ を推定して，逆フィルタ$H^{-1}$を周波数領域でかければよい。が，うまく戻らない部分がある。
- 逆フィルタの安定性の問題：$H$ がゼロ点を含むとその点で逆フィルタが発散してしまう
- ノイズの問題：逆フィルタではノイズを強調してしまう，推定誤差が結果に影響する
- 空間可変の $h$ となると，周波数領域での扱いは難しくなる（焦点ボケは均一ではなく，動きボケのカーネルも複雑）

そこで，ウィナーフィルタによる復元がよく使われる。
:::tip[ウィナーフィルタ]
劣化モデル： $G(u,v) = F(u,v)H(u,v)+N(u,v)$  
復元： $\hat{F}(u,v) = W(u,v)G(u,v)$ の期待値 $(E[|F-\hat{F}|^2])$ を最小にする

$W(u,v) = \frac{H^* (u,v)}{|H(u,v)|^2 + \frac{E[|N(u,v)|^2]}{E[|F(u,v)|^2]}}$
:::
- ウィナーフィルタの拡張例 $\min (||G - H \ast F||^2 + \lambda ||F||^2)$：高周波成分を強調する傾向を抑える

---
## 画像の幾何学的変換
### 線形変換
$\begin{bmatrix} x' \\ y' \end{bmatrix} = \begin{bmatrix} a & b \\ c & d \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix}$
- 拡大縮小：$\begin{bmatrix} s_x & 0 \\ 0 & s_y \end{bmatrix}$，
回転：$\begin{bmatrix} \cos \theta & -\sin \theta \\ \sin \theta & \cos \theta \end{bmatrix}$，
鏡映：$\begin{bmatrix} -1 & 0 \\ 0 & 1 \end{bmatrix}$

ただし，線形変換だと平行移動などを表現できない。
### 射影変換
$\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} = \begin{bmatrix} h_{11} & h_{12} & h_{13} \\ h_{21} & h_{22} & h_{23} \\ h_{31} & h_{32} & h_{33} \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$
ただし，$h_{33} = 1$ としてもよい。
- 平行移動：$\begin{bmatrix} 1 & 0 & t_x \\ 0 & 1 & t_y \\ 0 & 0 & 1 \end{bmatrix}$，
線形変換：$\begin{bmatrix} a & b & 0 \\ c & d & 0 \\ 0 & 0 & 1 \end{bmatrix}$，
アフィン変換（線形変換 + 平行移動）：$\begin{bmatrix} a & b & t_x \\ c & d & t_y \\ 0 & 0 & 1 \end{bmatrix}$

### 再標本・補間
幾何学的変換によって画像のサイズが変わると，画素位置がずれるので，再標本・補間が必要になる。他にも，画素を変更したい場合などに使う。
- ニアレストネイバー：最も近い画素の値をそのまま使う。画像が荒くなる
- バイリニア補間：周囲の4画素の重み付き平均を取る
- バイキュービック補間：周囲の16画素の重み付き平均を取る

### 超解像
- 事例に基づく超解像：データベース中の画像のパッチ（小領域）に対して，低解像度と高解像度の対応を学習する
- 深層学習による超解像：例）SRCNN (2014)，生成ベースの手法（本物っぽいかのずれを最小化）

### イメージモザイキング（スティッチング）
：複数枚の写真の対応関係をとって貼り合わせる
1. 特徴点検出とマッチング：特徴点（SIFT, SURF, ORB, DNN なら Geometric-matching CNN など）
2. 幾何学的変換の推定：射影変換行列を推定する。RANSAC などを用いる
3. 画像の合成

:::tip[RANSAC]
外れ値が含まれるデータから正確なモデルを推定するために使用する。**特徴点は外れ値を含むことが多い**ため。
1. ランダムサンプリングでデータを選択
2. データを学習してモデル ( = 射影変換行列) を推定
3. 全てのデータに対して評価を行い，正しく対応しているデータ（閾値以下）をインライヤとしてカウント
4. この処理を繰り返し，最もインライヤが多いモデルを採用する
:::
- RANSAC はめっちゃよく使うらしい
- 3. で，閾値以下でないデータを今後の学習で用いない場合もあるらしい
