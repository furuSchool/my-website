---
title: 7. スーパスカラプロセッサ
---

## 概要
:::tip[スーパスカラプロセッサ]
**同一サイクルに複数の命令操作を処理できるスカラプロセッサ。** 概ね汎用ISAのパイプラインプロセッサを指す。ほとんどのプロセッサはスーパスカラ !

暗黙的に ILP 抽出 (同時に行って良い操作を見つけ出す) をハードウェアが行う。また，パイプラインの埋まり方もハードウェアによって動的に制御される。
:::
つまり，パイプライン自体を並列化して複数用意する。
- ベクタプロセッサ : 単一の命令で複数のデータを処理するプロセッサ ( $\leftrightarrow$ スカラプロセッサ)
- SIMD (Single Instruction, Multiple Data) : 一つの命令で，複数の異なるデータに対して同時に同じ処理を実行する演算処理。GPU もこの原理に基づく
    - スーパースカラが命令レベルの並列性，SIMD はデータレベルの並列性

### 特徴
- パイプライン分割とは異なり，リソースが必要。単純には $n$ 倍，命令間の依存関係のチェックなどは $n^2$ 倍のコストが必要
- バブル対策が不可欠となる
    - 構造ハザード : 適切なポート数，エントリ数，FU (Function Unit) 数を確保する
    - 制御ハザード：分岐予測性能の向上，マルチスレッディング (MT) : ストール時に他のスレッドを実行する
    - データハザード : キャッシュ性能，OoO 実行 (out of order)，MT

---
## アウトオブオーダー実行 (OoO)
:::tip[アウトオブオーダー実行 (OoO)]
実行結果を正しく保ちながら，命令の実行順序を変更する技術。
一度命令をスケジューラに入れ，実行可能な命令から選択して実行する。
これにより命令間の依存関係を解消し，パイプラインの効率を向上させる。
:::
一般的な流れとしては，Fetch → Decode → Rename → Dispatch (命令をスケジューラへ) → Issue (スケジューラから発行) → Execute → Writeback → Commit/Retire となる。
- コードの順番通りに実行するのは イン・オーダ実行
- OoO の実現方法は複数存在する。その中でも，**レジスタ・リネーミング** は重要

### 命令間依存関係
ある命令が値を生成し，後続のある命令が値を使う場合。命令順序を入れ替える場合は注意が必要。依存関係には 以下の種類がある。
1. Read After Read (RAR) : 連続で同じレジスタを読み取る
    - 例 : ADD \$2, \$1, imm の後 ADD \$3, \$1, imm
    - read にステート更新の副作用がつく場合は問題だが，通常は入れ替えても問題ない
2. Read After Write (RAW) : 前の命令の生成値を後ろの命令が使用する。**入れ替えダメ !**
    - 例 : ADD \$2, \$1, imm の後 ADD \$3, \$2, imm
    - 違反しないよう，スケジューラによる発行 (issue) 制御を行う
3. Write After Read (WAR) : 前の命令で使用する値を後ろの命令が上書きする
    - 例 : ADD \$2, \$1, imm の後 ADD \$1, \$3, imm
    - 後ろの命令の rd がたまたま同じだけなので，別のレジスタを rd に割り当てることで入れ替えられる = **レジスタ・リネーミング**
4. Write After Write (WAW) : 前の命令の生成値を後ろの命令が上書きする
    - 例 : ADD \$2, \$1, imm の後 ADD \$2, \$3, imm
    - これも **レジスタ・リネーミング** で OK

---
## レジスタ・リネーミング
:::tip[レジスタ・リネーミング]
コードに書かれている論理レジスタ番号を，実際に使われる物理レジスタ番号へ読み替える技術。
ハードウェアがパイプラインの一部として行う。
:::
この時，ソフトウェアが認識するレジスタ数と物理レジスタ数は異なってもよい。
なお，これは各命令ごとに行われる

### ソースレジスタ (r1, r2) の決定ロジック
:::note[RMT]
**RMT (Renaming Map Table)** : レジスタ・リネーミングを行うためのテーブル。2 種類の方式がある。
1. RAM 型 : 論理レジスタ番号に対応する行を取り出せば，物理レジスタ番号が得られる
2. CAM 型 : 論理レジスタ番号を key として，物理レジスタ番号を検索する
:::

- Read にはポート数 「フロントエンド幅 * (r1,r2 と rd の論理レジスタ数)」分，Write にはポート数 「フロントエンド幅 * rd の論理レジスタ数」分必要。多いが，それだけ重要

### デスティネーションレジスタ (rd) の決定ロジック
命令ごとに，フリーリスト (上書きしても良い物理レジスタのリスト) から選んでまだ使っていない物理レジスタを割り当てる。
- RAM 型の場合，命令によって同じ論理レジスタが書き換わるとしても，新たに別の物理レジスタが使われる。この時，前の論理レジスタに対応する物理レジスタはフリーリストに戻される
- 投機ミスの場合もフリーリストと RMT を元に戻して対応する

--- 
## RAW の制御
1. ソースオペランドが全部揃ったことを確認する必要がある (ウェイクアップロジック)。
これは，実行中の命令の物理 rd を全て確認して，各物理アドレスが ready かを示すようにする
2. 両方のソースオペランドが ready であれば，wake up 信号をオンにする
3. wake up 信号がオンのものから select logic によって発行する命令を決定する

ここまでを 1 クロックで行わねばならず，しばしばクリティカルパスとなる。

### メモリ命令の場合
メモリ命令だと E ステージまでアドレスが分からず，スケジュール時に依存関係がわからない。
安全にする方法としては，フロントエンドで仮想的に依存チェーンを貼る，メモリ依存予測を使う，などがある。
- ストアキュー : ストア命令のアドレスと値を保持。後続のロードアドレスが一致した場合はストアキューから読み出す。正確な管理方法には PNR などがある

