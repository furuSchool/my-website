---
title: 4. プロセッサ
---

## プロセッサ
:::tip[プロセッサ]
命令を順次処理するための装置。CPU (Central Processing Unit) とも呼ばれる。
1. **命令フェッチ** : 命令を，PC (Program Counter) に従って，メモリ (命令メモリ, imem ) から読み出す
2. **命令デコード，レジスタリード** : 読み出した命令 (32 bit) を ISA に従って decoder でデコードし，レジスタからオペランドを読み出す
    - decoder で rs1 (5 bit), rs2 (5 bit), rd (5 bit), func_code (7 bit), opcode などを抽出する
    - rs1 (5 bit), rs2 (5 bit) に対応するアドレスのレジスタから値を読み出す
3. **実行** : rs1, rs2, imm (即値), PC の中から，opcode により operand switcher で適切な値を選択し，func_code に従って ALU で演算を行う
4. **メモリ書き込みや読み出し** (load/store 命令の場合)
    - また，branch 命令や jump 命令の場合はこのタイミングで PC の更新をする (ALU の出力によって NPC (Next Program Counter) が決まるため)
5. **レジスタライト** : 実行結果をレジスタ (アドレスは rd (5 bit)) に書き込む
:::

**シングルサイクルプロセッサ** : 1 クロックで 1 命令を実行するプロセッサ。つまり，1 クロックで上記の流れ全てを実行できるようにする。クロック周期は長くなる

**パイプラインプロセッサ** : 複数の命令を少しづつずらしてオーバラップ実行するプロセッサ。クロック周期を短くできる

---
## パイプラインプロセッサ
シングルサイクルプロセッサでは，1 クロックで 1 命令を実行するため，クロック周期は長くなる。
そこで，命令を複数の段に分けて並列に処理することで，クロック周期を短くし，クロック周波数を高くすることができる。

- 基本的には，FF (パイプラインレジスタ) で命令の各段を分ける
    - 例えば，F(フェッチ), D(デコード), R(レジスタリード), E(実行), M(メモリ書き込み), W(レジスタライト) の 6 段などに分けられる
- 効果 : $n$ 段で約 $n$ 倍のクロック周波数を実現できる (実際は $n$ 倍にはならない)
    - **レイテンシは伸びる** : パイプラインレジスタの遅延やステージ遅延
    - **スループットは向上する** : クロック周期が短くなるため，1 クロックで 1 命令を実行できる
        - ただし，クロックのオーバヘッドやパイプラインバブルの影響で，理論値よりは低くなる
- なるべく，各ステージのクリティカルパスが同じ長さになるように分割する
- 分割すればするほど，クロックのオーバヘッド (クロックスキュー，ジッタ，マージンなど) が増える
    - クロックスキュー : クロック信号が各 FF に到達するまでの時間差
    - ジッタ : クロック信号の周期のばらつき
    - マージン : クロック周期に対する余裕時間 (熱や電圧降下などに耐えるため)

また，パイプラインの性能指標として，スループットやレイテンシの他に **CPI (Cycles Per Instruction)** がある。バブルがどの程度発生しているかを表す指標。
- **CPI** : 1 命令あたりのクロック数。理想的には 1。1 より大きいほどバブルが発生している

---
## パイプラインストール
:::tip[パイプラインストール]
パイプラインプロセッサの中で，命令が実行されず止まってしまう状態。以下の 3 つの原因がある。
1. **構造ハザード** : 同じハードウェアリソースを複数の命令が同時に使用しようとした場合
2. **データハザード** : 他の命令によって生成されるデータが間に合わない場合
3. **制御ハザード** : 分岐命令が実行される前に，次の命令をフェッチしてしまう場合
:::
この時，**バブル** と呼ばれる空のステージを挿入することで，パイプラインを止めることができる。
- 具体的には，バブルの部分の命令は NOP 命令とし，それ以前のパイプラインレジスタは更新せず，PC も更新しない。(ストール) 命令をそのまま持っておくイメージ

### 構造ハザード
:::note[構造ハザード]
同じハードウェアリソースを複数の命令が同時に使用しようとした場合。RISC では基本的に発生しない。
例えば，パイプライン化されたプロセッサで，命令フェッチとメモリ書き込みを同時にできないとかはありうる。
:::

### データハザード
:::tip[データハザード]
他の命令によって生成されるデータが間に合わない場合。
例えば，レジスタライトする前にそのデータをレジスタリードしようとする命令が来てしまった場合。
$\to$ 頻発するので，**フォワーディング** という手法を使う。
:::
つまり，依存のある命令を連続実行できないこと
- 例 :
    ```assembly
    add x1, x2, x3  # x1 = x2 + x3
    sub x4, x1, x5  # x4 = x1 - x5 (x1 の値が書き込まれていない)
    ```
    - "-" がバブル。レジスタライト (W) が終わるまでレジスタリード (R) ができない
        <table>
        <tbody>
            <tr>
            <td>add</td>
            <td>F</td>
            <td>D</td>
            <td>R</td>
            <td>E</td>
            <td>M</td>
            <td>W</td>
            </tr>
            <tr>
            <td>sub</td>
            <td>*</td>
            <td>F</td>
            <td>D</td>
            <td>-</td>
            <td>-</td>
            <td>-</td>
            <td>R</td>
            <td>E</td>
            <td>M</td>
            <td>W</td>
            </tr>
        </tbody>
        </table>
- ソフトウェアコンパイルを最適化して，なるべく依存しないようにもできる

### フォワーディング
バイパスを作ることで，レジスタライトする前に使えるようにするイメージ。最短では，前のサイクルの ALU の結果をそのまま次の ALU の入力に使う。
<table>
<tbody>
    <tr>
    <td>add</td>
    <td>F</td>
    <td>D</td>
    <td>R</td>
    <td>E</td>
    <td>M</td>
    <td>W</td>
    </tr>
    <tr>
    <td>sub</td>
    <td>*</td>
    <td>F</td>
    <td>D</td>
    <td>R</td>
    <td>E</td>
    <td>M</td>
    <td>W</td>
    </tr>
</tbody>
</table>
- この場合，add の E の出力 $\to$ sub の E の入力のフォワーディング
- 他にも，M の出力 $\to$ E の入力，W の出力 $\to$ E の入力，などのフォワーディングパスもある
- ただし，ロード命令の結果をフォワードする場合は，必ず 1 クロックバブルが発生してしまう
    - M の出力を E の入力として使う必要があるため
- ちなみに，フォワーディングパスがクリティカルパスとなることが多い

### 制御ハザード
:::tip[制御ハザード]
次の命令がわからない場合。分岐命令やジャンプ命令がある場合に発生する。対策として，二つの方法がある。
1. 命令がわかるまでパイプラインストールする
2. **分岐予測** : 分岐後の PC を予測して進む。予測が外れた場合のリカバリ機能も同時に実装する
:::
- 遅延分岐 : コンパイラの最適化によって，分岐命令直後に依存関係のない命令を配置し，その後に分岐を適用する手法。ほとんど使われない
- パイプラインストールする場合，E の段の出力でフェッチする命令のアドレスが決まるため，この場合だと最大 4 サイクルストールする
    <table>
    <tbody>
        <tr>
        <td>beq</td>
        <td>F</td>
        <td>D</td>
        <td>R</td>
        <td>E</td>
        <td>M</td>
        <td>W</td>
        </tr>
        <tr>
        <td>sub</td>
        <td>*</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>F</td>
        <td>D</td>
        <td>R</td>
        <td>E</td>
        <td>M</td>
        <td>W</td>
        </tr>
    </tbody>
    </table>

### 分岐予測
方向予測 (前回の分岐方法) とBranch Target Buffer (前回の飛び先) をキャッシュしておき，次の分岐命令の予測を行う。
- 単純には，同じ PC の命令が来た時に前回と同じ NPC を予測する (キャッシュで保存)

それと同時に，予測ミスした場合の対策を考える。
1. E の出力で，分岐予測が当たっていたかがわかる
    - beq 以下の F は予測したアドレスにフェッチしている
        <table>
        <tbody>
            <tr>
            <td>beq</td>
            <td>F</td>
            <td>D</td>
            <td>R</td>
            <td>E</td>
            </tr>
            <tr>
            <td>命令1</td>
            <td>*</td>
            <td>F</td>
            <td>D</td>
            <td>R</td>
            </tr>
            <tr>
            <td>命令2</td>
            <td>* </td>
            <td>*</td>
            <td>F</td>
            <td>D</td>
            </tr>
            <tr>
            <td>命令3</td>
            <td>* </td>
            <td>* </td>
            <td>*</td>
            <td>F</td>
            </tr>
        </tbody>
        </table>
2. 予測ミスと判明
    - F の出力を正しい PC からフェッチした命令にする
    - F-D 間，D-R 間，R-E 間のパイプラインレジスタの出力を NOP にする (パイプラインフラッシュ)
    - つまり，命令をやり直し
        <table>
        <tbody>
            <tr>
            <td>beq</td>
            <td>F</td>
            <td>D</td>
            <td>R</td>
            <td>E</td>
            <td>M</td>
            </tr>
            <tr>
            <td>命令1</td>
            <td>*</td>
            <td>F</td>
            <td>D</td>
            <td>R</td>
            <td>E(NOP)</td>
            </tr>
            <tr>
            <td>命令2</td>
            <td>* </td>
            <td>*</td>
            <td>F</td>
            <td>D</td>
            <td>R(NOP)</td>
            </tr>
            <tr>
            <td>命令3</td>
            <td>* </td>
            <td>* </td>
            <td>*</td>
            <td>F</td>
            <td>D(NOP)</td>
            </tr>
            <tr>
            <td>命令1</td>
            <td>* </td>
            <td>* </td>
            <td>* </td>
            <td>*</td>
            <td>F</td>
            </tr>
        </tbody>
        </table>

---
### 例
<img src="/img/information/processor.jpg" alt="プロセッサの例" style={{ width: '90%' }} />

上記では，命令フェッチ，命令デコード，レジスタリード，実行，メモリ書き込み + レジスタライトの 5 段に分割されている。