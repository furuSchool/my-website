---
title: 3. 命令の詳細
---
:::warning[命令とは]
**命令はコンピュータの動作を指定する情報.** ビット列で表現される. 命令を繰り返すことで, アルゴリズムやプログラムを実現する.  
命令に含まれる情報：**どのデータに**（= 対象, オペランドで指定）**何をするか**（= 操作, OPCODE で指定）
:::

---

## アセンブリ言語
- 機械語：コンピュータの回路がそのまま解釈できる 0 と 1 のビット列
- アセンブリ言語：自然言語に近い記号（ニーモニック）で標記. 人間によるコーディングが可能（ハンドアセンブル）
    - 基本的に機械語と 1:1 対応
- アセンブラ：アセンブリ言語で書かれたコード列を機械語コード列へ変換するプログラム
{/* - その他注意
    - PC（= 命令アドレス） + 4 は, メモリ4バイト先のとこに制御が移ることを表す
    - アセンブラが自動変換するので機械語は回路の都合で並びを決定する
    - アセンブラはシンボルを利用可能（アドレス変位などをアセンブラで計算）
    - 使い方の慣例に合わせてレジスタ番号に特定の名前がつくことも */}

---

## 命令セット
:::tip[命令セットとは]
そのコンピュータが解釈・実行できる全ての命令の集まり
:::
### 命令セットアーキテクチャ
：ソフトウェアからみたコンピュータの仕様
- どのようなソフトウェア可視ステートを持ち, どのような命令がどのようなコードで表現され, 命令がどのようにステートを更新するか, メモリがどのように使われるか
- ハードウェア設計, ソフトウェア設計それぞれの基点. 命令セットアーキテクチャの設計 = ハードウェアとソフトウェアの界面の設定

### 命令セットの設計方法
1. コンピュータが意図するタスクを遂行可能な命令群を設定する
    - 「汎用コンピュータ」「汎用プロセッサ(General Purpose Processor:GPP)」：任意のプログラムに対応可能
2. 一命令の「粒度」を設計する
    - ミニマムな設計：最小限の操作, 最小限のオペランド数, RISC（Reduced Instruction Set Computer）
        - 命令長「小」, 命令種類「小」
    - リッチな設計：ルーチンに近い機能を持つ操作, 必要に応じたオペランド数, CISC（Complex Instruction Set Computer）
        - 命令数/プログラム「大」, ハンドアセンブル「易」, 操作/メモリアクセス「大」
    - 固定長：どの命令も一律で同じビット長
        - 命令の長さがわかる, 次の命令アドレスの予測が容易
    - 可変長：命令の操作やオペランドに応じて異なるビット長
        - ビットを過不足なく使える, 即値やオペランド数, アドレシングを必要な長さに調整可能

### オペランド
：命令がどのデータにアクセスするか, その対象. 下記のようなものがオペランドとして指定される
- レジスタ（レジスタファイル）
- プログラムカウンタ
- メモリ中のデータ
    - ロードストアアーキテクチャだと, メモリオペランドをとらない. レジスタを介してメモリアクセスを行う
- その他のレジスタ（フラグなど）
- 即値（命令に含まれる値）

#### オペランドアドレシングの設計：どう命令がオペランドにアクセスするか
制限的にするか, 柔軟にするか
- 制限的なものの例：ロードストアアーキテクチャ, アドレシングはレジスタ番号のみ

どうやってアドレシングするか
- レジスタ番号指定：基本これ
- メモリアドレス指定：メモリアドレスを直接指定
    - ロードストアアーキテクチャでは禁止. レジスタ間接でアクセス.
- レジスタ番号＋オフセット（インデックス）：配列の要素へのアクセスなど
- メモリアドレス＋変位
- レジスタ間接：レジスタが保持する値をアドレスとして間接的にメモリへアクセス
- メモリ間接：メモリ内に格納されたアドレスを基にさらに別のメモリ位置を指定

---

## 命令セットの実例 - RISC-V - 
### RISC-Vの特徴
- **ミニマムに近い命令粒度**
    - 1~2入力1出力, フラグなし, メモリアクセス命令：アドレス計算＋メモリアクセスで１命令
- **固定長(32 bit)**
    - レジスタは, 32本あり, 32 bit 幅
- **命令毎にオペランド種類とフィールド固定**

### RV32I命令セット
仕様書：https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf

命令の種類は4種類のみ！
1. 算術論理演算命令：オペランドに対して操作
2. 制御命令：PCに対して値を変更
3. データ転送命令：メモリとのやりとり, メモリにリクエストを出す
4. システム命令：OSと協調して, システム全体の仕事をする

### 詳細な命令一覧
<img src="/img/information/rv321.png" alt="命令一覧" style={{ width: '50%' }} />
上記は仕様書より一部引用. 覚えるというよりは, どんな感じの命令があったか仕様書などを見て思い出せれば良い.
- rs1, rs2：ソースレジスタ
- rd：デスティネーションレジスタ
- imm：即値
#### 1. 算術論理演算命令
- レジスタ2つの算術演算：ADD, SUB, SLT, SLTU（基本の和差, 比較）
- レジスタ1つと即値1つの算術演算：ADDI, SLTI, SLTIU（即値利用の和差, 比較）
- レジスタ2つの論理演算：AND, OR, XOR, SLL, SRL, SRA（論理演算, シフト演算）
- レジスタ1つと即値1つの論理演算：XORI, ORI, ANDI, SLLI, SRLI, SRAI（即値利用の論理演算, シフト演算）
- 即値1つの論理演算：LUI（即値をrdの上位20bitにセット）
- PCと即値1つの論理演算：AUIPC（32bitの即値をPCに加算して結果をrdに書き込み（即値の下位12bitは0で埋める））
#### 2. 制御命令
- ジャンプ命令：JAL（NPC = PC + 即値; rd = PC + 4）, JALR（NPC = rs1 + 即値; rd = PC + 4）
- 条件分岐命令： BEQ, BNE, BLT, BGE, BLTU, BGEU
#### 3. データ転送命令
- ロード命令：LB, LH, LW, LBU, LHU
- ストア命令：SB, SH, SW

### その他
#### サブルーチンコール：関数みたいなもの. 手続き呼び出しを効率化する命令
1. JAL x1,[手続きの先頭命令アドレスまでの変位]（帰ってくるべきアドレスを$x1に格納. RISC-Vの慣例：ra→ x1）
2. 制御ポイントを手続きアドレスへ移す
3. 手続きから戻るとき(return)は, JR x0,x1（JALR ）
- 引数の受け渡し
    - 引数レジスタ(RISC-V慣例では x10-17 (a0-7))
    - sp(RISC-V慣例ではx2)を基点としてメモリで受け渡し
- アドレスや引数を書きつぶしてしまうとやばい. スタックに保存することも. （→ スタックオーバーフロー攻撃とかもある）

#### if-then-elseの実現
> BNE x3, x4, Else(この例であれば12)  
> ADD x7, x5, x6  
> J Exit (この例であれば8)  
> Else: sub x7, x5, x6  
> Exit:

#### loopの実現
> for, while, …など.   
> 終了判定：bne~, beq~  
> ループ：ｊ~

#### 32bit定数の生成
LUIとORIと組み合わせて2命令で任意のワード値を生成可能

#### NOP/MV
ADDIはNOPやMVの実装にも使われる. 
- NOP（何もしない）: ADDI x0 x0 0, MV（コピー）: ADDI rd rs1 0

#### エンディアン
：メモリにデータを格納する際の順序. アドレススペース 32bit（メモリアドレスはこれで表せる）
- リトルエンディアン：下位バイトから格納
- ビッグエンディアン：上位バイトから格納