---
title: 7. ファイルシステム
---

:::warning[ファイルシステムの目的]
二次記憶装置に対して OS が提供している抽象化（仮想概念）. 
色々な二次記憶装置を簡単な共通のインターフェイスで読めるようにしている
:::
- 二次記憶装置：ハードディスク, SSD, USB メモリ, SD card
- ファイル：自由に伸縮できるバイト配列
- ディレクトリ・フォルダ：他のファイルやディレクトリを含む入れ物
- 名前空間：ファイル・ディレクトリに名前をつけられる

### 簡単な仕組み
めっちゃ当たり前のこと. 飛ばしても良さそう. 
- ファイルシステム全体は一つの木構造で, **リーフ = ファイル**, **リーフでない内部ノード = ディレクトリ**
- 任意のディレクトリは木構造の根（ = **ルートディレクトリ**）からそれに至る道（ = **絶対パス**）を指定すれば一意に特定できる
    - 例： `/usr/bin/python`  `/` がルートを表す
- 任意のディレクトリを起点としたディレクトリへのパス = **相対パス**
    - 親ディレクトリを `..` で指定
    - 各プロセスには起点となる現在のディレクトリ（= **カレントディレクトリ**）がある
    - カレントディレクトリの変更： `chdir` のシステムコール, シェルの `cd` コマンド

---
## ファイルシステムのAPI
:::tip[ファイルシステムのやりとり]
- ファイルオフセット：次の読み書きが行われる場所。二次記憶上のファイルの先頭からのバイト数
- 論理アドレス空間上の配列 `buf` と二次記憶上のファイルの間でデータの読み書きをするイメージ
:::

#### `int fd = open(path, flags[, mode]);`：path で指定されるファイルを開く, 場合により新たに作る
- 成功すれば, 後に `read/write` などに渡す用の **ファイルディスクリプタ** `fd` を返す (実体はただの整数)
    - `open` 直後はファイルオフセット 0
- `flags`
    - `O_RDONLY, O_WRONLY, O_RDWR` : 読むだけ, 書くだけ, 両方
    - `O_CREAT` : 存在しなければ作る
    - `O_EXCL` : 存在していたらエラー
    - `O_TRUNC` : 存在していたら一旦空 (0 バイト) にする

#### `ssize_t r = read(fd, buf, sz);`：ファイルオフセットから最大 sz バイト, アドレス buf から始まる領域に読み込む
- 実際に読み込まれたバイト数を返す
- ファイルオフセットが r 前進する

#### `ssize_t w = write(fd, buf, sz);`：アドレス buf から始まる領域から, 最大 sz バイトを, ファイルオフセットに書き込む
- 場合によりファイルが伸長する
- 実際に書き込まれたバイト数を返す
- ファイルオフセットが w 前進

#### `off_t o = lseek(fd, offset, whence);`：ファイルの一部だけを読み書きできる
- ファイルオフセットを `whence` に応じた `offset` にする
- `whence` ：`SEEK_SET` ファイル先頭から, `SEE_CUR` 現在位置から, `SEEK_END` ファイル終わりから

:::note[その他の API]
ほとんどメモ. 飛ばしても良さそう

---
`ssize_t r = pread(fd, buf, sz, offset);`：offset から最大 sz バイト, buf から始まる領域に読み込む  
`ssize_t w = pwrite(fd, buf, sz, offset);`：buf から始まる領域から, 最大 sz バイトを, offset に書き込む
- **途中から書き込める**
- **ファイルオフセットは変わらない**
---
`readv, writev` ：複数の `read, write` を一撃で実行できる

---
`int e = fallocate(fd, mode, offset, len);`：ファイルの `[offset, offset + len)` バイトの範囲を, 必要ならばファイルを伸長し, 0 にする  
`int e = ftruncate(fd, off_t, len);`：ファイルの大きさを len バイトに, 短縮 (伸長できる OSもある) する
- ファイルの大きさの伸縮のために利用

---
`int e = close(fd);`：`open` したファイルを閉じる (`fd` が無効になり, 以降の `open` における再利用の対象になる)  
`int e = unlink(path);`：ファイルを消す（ファイルのリンクを断ち切る）
:::

### mmap（重要）
:::tip[mmapの役割]
1. ファイルを「メモリ上にあるかのように」読み書きする
2. メモリを割り当てる ( `sbrk` の役割を兼ねる)
3. 割り当てるアドレスを指定する (疎なアドレス空間)
4. 読み書き保護を設定する

**論理アドレス空間とファイルシステムを対応づけ, 保護属性を設定する**
:::

#### `void * a = mmap(a0, len, prot, flags, fd, o);`
- `fd` に対応するファイルの `o` バイト目から `len` バイトが返り値のアドレス `a` に対応づけられる $\rightarrow$ `a[i]` がファイルの `(o+i)` バイト目に対応する
- 返り値 `a`：これまで使っていなかったアドレス $\rightarrow$ メモリを新たに割り当てる
- `prot`：割り当てられた領域の保護属性
    - `PROT_READ, PROT_WRITE, PROT_EXEC` : 読み出し可能, 書き込み可能, （命令として）実行可能
- `flags`：割り当てられた領域の属性
    - `MAP_SHARED` : 書き込みはファイルへ反映, プロセス間で共有
    - `MAP_PRIVATE` : 書き込みはファイルへ反映せず, プロセス間でも共有しない
- `a0`：割り当てるアドレスを指定
    - `a0 ≠ 0` $\rightarrow$ アドレス `a0` を割り当てる, 空いていない場合はエラー
    - `a0 = 0` $\rightarrow$ OSが開いているところを割り当てる

#### コード例
```c
// ファイル読み込み
int fd = open(filename, O_RDONLY);
struct stat sb[1]; // ファイルサイズの指定
if (fstat(fd, sb) == -1) err(1, "fstat"); // man err 参照
long sz = sb->st_size;
char * a = mmap(0, sz, PROT_READ, MAP_PRIVATE, fd, 0);
/* filename の i バイト目が a[i]で読み出せる */
for (long i = 0; i < sz; i++) {
    putchar(a[i]);
}

// ファイル書き込み
int fd = open(filename, O RDWR|O_TRUNC|O_CREAT, 0777);
posix_fallocate(fd, 0, sz); /* ファイルを sz バイトにする. 自由には伸びない */
char * a = mmap(0, sz, PROT_READ|PROT_WRITE, MAP SHARED, fd, 0);
/* a[i]に書き込むと{\it filename}の i バイト目に書き込むことになる */
for (long i = 0; i < sz; i++) {
    a[i] = i % 128;
}
munmap(a, sz); // a から sz バイトを解放
close(fd);

// メモリ割り当て
long sz = 2 ** 12 // 4KB
char * a = mmap(0, sz, PROT READ|PROT WRITE, MAP PRIVATE|MAP ANONYMOUS, -1, 0); // ファイルに対応づけない
```
- メモリ割り当ては, 保護属性を指定可能 (`PROT xxx`), 個別に解放 (`munmap`) 可能, 割り当てるアドレスを第一引数 (`mmap(a0, ...)`) で指定可能
という点で `sbrk` とは異なる

:::warning[mmap, sbrk と malloc, new の違い]
- `mmap, sbrk`： OS のシステムコールであり, 特定のアドレス空間にページ単位でメモリを割当・開放
- `malloc, new`： C のライブラリ関数.  `mmap, sbrk` を内部的に利用. ページより細かい単位での割当・開放
:::

---
## キャッシュ
:::warning[注意]
プロセッサが行うキャッシュとは異なる. OS が行う, ファイルシステムのキャッシュについて説明する
:::

:::tip[キャッシュの役割]
ファイルの一部分や書いたファイルをメモリ（キャッシュ）上に保持し, 二次記憶とのIOを行わずに読み書きできるようにする
- だって二次記憶から読むの主記憶と比べてめっちゃ遅いもん
:::
- 売られている HDD 装置の性能：1本でおおよそ100MB/sec
- 売られている SSD 装置の性能：1本でおおよそ200-300MB/sec (SATA接続) 〜 1-2GB程度/sec (PCI接続)
- 主記憶の性能：メモリの搭載の仕方にもよるが数十GB 〜 数百GB/sec
- プロセッサは数GHzとか $\rightarrow$ 主記憶ですら遅い

### キャッシュの流れ
:::tip[キャッシュの流れ]
まずは, 二次記憶にアクセスするためにファイルシステムの API を使ってファイルを開く  
（ファイルシステムがアドレス空間と二次記憶の仲介のイメージ）
- read 要求された部分がキャッシュ上にない
    1. カーネル(OS)内に領域を割り当て
    2. 二次記憶からキャッシュ上に読み込む = 物理メモリ上にコピー
    3. プロセス指定の物理メモリ上にもコピー（キャッシュとは違う領域で, プロセスがアクセスする用）
- read 要求された部分がキャッシュ上にある
    1. キャッシュからプロセス指定のメモリにコピー（高速！）
:::

### 先読み
:::tip[先読み]
プロセスが要求していない部分を先にキャッシュ内に読んでおくこと. モチベーションは以下の通り
- ファイルの読み出しが連続した部分で行われている時など
- 小さなデータも遅延は同じ $\rightarrow$ なるべく一気に多くのデータを二次記憶から読み込みたい！
:::

---
## `mmap`の実装
`void * a = mmap(a0, len, prot, flags, fd, o);`
### `mmap` が実際に行うこと
:::tip[`mmap` が実際に行うこと]
1. 仮想メモリ割り当て（物理メモリは割り当てられない）+ **仮想アドレスの範囲とファイル範囲の対応関係を記録**
2. 仮想メモリにアクセス $\rightarrow$ CPU が「ページフォルト」例外（マイナーフォルト）を発⽣し,  
OSが物理メモリから空き領域を探索, **内容をファイルから（ = ページング領域から）読み出して**物理ページを割り当て
    - この時に, 記録していた対応関係を使う
3. ページテーブルや TLB に記述する
:::
- ページング領域：仮想記憶の際に使われる物理メモリが不足した時用の二次記憶上の領域

### 普通のメモリ管理の流れ
1. 仮想メモリ割り当て（物理メモリは割り当てられない）
2. 仮想メモリにアクセス $\rightarrow$ CPU が「ページフォルト」例外（マイナーフォルト）を発⽣し, 
OSが物理ページを割り当て（要求時ページング） 
    - swapされてしまっていたら（メジャーフォルト）, ページング領域から読み込み：これが `mmap`の動作に近い
3. ページテーブルや TLB に記述する

すなわち, `mmap` はページング領域として任意のファイルと対応づけることができるようにしたに過ぎない

### `mmap`の共有マッピングとプライベートマッピング
#### 共有マッピング `flags = MAP_SHARED |…` ：書き込みがファイルに反映され, 複数プロセス間で共有
- 同じファイル（ファイル + オフセット）に対しては同じ物理アドレス（ページ）を用いる = 物理メモリ上に 1 つのメモリ
- 実は、キャッシュと同じ物理ページ
        
#### プライベートマッピング`flags = MAP_PRIVATE |…` ：書き込みがファイルに反映されず, 複数プロセス間で共有されない
- 書き込みが実際に起こるまでは同じ物理ページを用いる（**コピーオンライト**）
    - 変更されるまで物理アドレスを共有しつつ, MMU の機能で書き込み不可にしておく
    - 書き込み時に例外発生 $\rightarrow$ OS が物理メモリにコピーしてそのページへマッピングを変更

一方で, `read` はプロセスが異なれば物理アドレスも異なる

### `mmap`が効果的な場面
- 大きなファイルのごく一部を飛び飛びにアクセスする： `mmap` でファイル全体をマップする
    - 仮想アドレスにアクセスがあって初めて物理メモリが割り当てられるため
    - 典型例：大きなデータの索引（探索木やハッシュ表）
- 多くのプロセスが同じファイルをアクセスする
    - `read` だとプロセスごとに別だけど、 `mmap` なら物理ページを共有されるため
- プログラム（命令）の読み込み, 特に多くのプログラムが用いるライブラリ（GUI など）
    - 上記二つの性質を併せ持つため
