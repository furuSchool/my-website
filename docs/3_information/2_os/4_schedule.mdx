---
title: 4. スケジューリング
---
## 基本
:::warning[スケジューリングの目的]
スレッドに CPU（仮想コア）を割り当てる！けど, どのスレッドから実行する？
:::
- スレッドは, **実行中, 実行可能, 中断中**の3つの状態がある. ほとんどのスレッドは中断中
    - `ps auxww` などで見ると……R：実行中または実行可, S：中断中 (割り込み可能), D：中断中 (割り込み不可能)
#### コンテクストスイッチ
現在実行中のスレッドがこれ以上実行不能と判断する時, 別のスレッドに切り替える. 以下は例
- `read`, `recv` などブロッキング I/O で読むデータがない
- `waitpid`, `pthread_join` などで, 子プロセス・スレッドが終了していない
- `pthread_mutex_lock`, `pthread_cond_wait` など同期API で同期が成立していない
- `sleep`, `usleep`, `nanosleep` など休眠 API
- ページフォルトで I/O が発生

#### タスクキュー, ランキュー
実行中・実行可状態のスレッドを維持する. （キューとか言いつつFIFOとは限らない）  
スレッドを切り替える際, OSはランキュー中から, ある基準に従って次のスレッドを選んで実行する.

#### Preemption
スレッドが自発的に OS に制御を渡さない (何もシステムコールを呼ばずに走り続けている) 状態でも, 強制的に制御を奪うこと. タイマ割り込みで実現される. 
また, preemption を行うスケジューラを, preemptive なスケジューラと呼ぶ. 
- 長すぎる時とかに一旦ランキューの後ろに回すイメージ

以下のコードは**CPUの命令実行**の例で, 割り込みが来たら PC を割り込みベクタのアドレスに書き換える.
```c
while (1) {
	// PC の指すアドレスから命令を読み,実行する (PCを含め一部のレジスタが書き換わる)
	if (割り込みが来た) {
		PC := 割り込みベクタ [割り込み番号]; // PC = プログラムカウンタレジスタ
	}
}
```
---

## スレッドの選択方法

#### Round Robin (純粋なかわりばんこ)：ランキューが純粋なFIFO
- 全てのスレッドが同じ扱い
- load average（負荷平均） が高いと( = 実行可能なスレッドが多いと), 対話的なプログラムの応答性が悪くなる
- FIFO, LIFO などの[参考記事](https://qiita.com/pb10005/items/970c0aa7120598949d01)
#### Linux Completely Fair Scheduler (CFS)：スケジューラ
- 各スレッドが「消費した合計 CPU 時間のようなもの (= vruntime)」を管理し, 実行可能スレッド中で vruntime が最小のスレッドを次に実行
= **vruntime の小さい順にスレッドが並ぶ優先度キュー**

:::tip[CFSの仕組み]
1. B.vruntime = A.vruntime（生成時は親の vruntime を継承. 親スレッド A が子スレッド B を生成）
2. T.vruntime += Tが今回消費したCPU時間（タイマ割り込み/スレッド中断時に, 実行中だったスレッド T の vruntime を加算）
3. T.vruntime = max(T.vruntime, min(t.vruntime−20ms))  （"時間貯金"をしすぎないように配慮. この場合は 20ms まで）
:::