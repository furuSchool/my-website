---
title: 6. メモリ管理
---

この章も重めです. アーキテクチャとも関連があります.

## メモリとは
詳細は, アーキテクチャの記事も参照. 
- コンピュータには主記憶 (メインメモリ, 単にメモリ) が搭載されており, 典型的な大きさは, 4GB (ノート PC) ～ 256 GB (サーバ)
- CPU は**アドレス**を指定してメモリを読み書きする
- プログラムが使うデータはほぼ全てメモリの中にある
    - 本当に計算する時は, レジスタにロードしてきて計算する
    - メモリを使う手段：大域変数・配列, 局所変数・配列, ヒープ（例えば C だと）= アドレスに名前をつけただけ
:::warning[ポインタ]
C 言語などでは, ポインタを使ってメモリを扱うことが多い. ポインタはアドレスを格納する変数.
:::

---

## 論理アドレスと物理アドレス
:::tip[論理アドレスと物理アドレス]
- 論理（仮想, virtual!?）アドレス：プロセスがプロセスごとに使うアドレス. 1プロセスに1論理アドレス空間で, 同じ論理アドレスが全プロセスにある
- 物理アドレス：物理メモリを実際にアクセスするときのアドレス
:::
別に合ったほうが何かと便利. 対応関係は後で取る.
- アドレスの範囲は物理メモリの量によらない. ソフト（OS）が決める
- アドレス変換はCPUが行う（論理アドレス → 物理アドレス）
- 論理アドレスに対応する物理アドレスがない場合もある（ページフォルト）

---

## メモリ管理ユニット (MMU)
:::tip[MMU]
CPU 内のハードウェアで全メモリアクセスに介在し, **論理アドレス**に対して下記のことを行う
1. アクセス権の検査（ユーザモードで読み出しできるのか, supervisorモードが必要なのかなど）
2. 対応する物理アドレスが存在するかの検査
3. 論理アドレスから物理アドレスへアクセス
:::
何かと便利な仮想メモリの管理をしているイメージ. 下記のような機能を持つ（MMUのメリットというか, 仮想アドレスのメリットというか）
- メモリ保護機能：プロセス間でメモリの分離 
- カーネル (OS) データの保護
- 物理メモリ量を越えたメモリ割り当て
- 要求時ページング (on demand paging): 物理メモリを確保せずに, メモリ割り当てを (高速に) 行える

--- 

## アドレス変換
詳細はアーキテクチャの記事も参照.
:::warning[目標]
**論理アドレスと物理アドレスの対応を取る！** = 論理アドレス → (アクセス許可, 物理アドレス) の写像を作りたい
:::

### ページ
:::tip[ページ]
論理アドレスで, 下位 A bit 以外が共通の $2^A$ 個のアドレスからなる領域のこと.
- ページサイズは $2^A$ byte（典型例は, $A = 12$, ページサイズ：4KB）
- 下位 A bit：ページ内オフセット
- それ以外の上位 bit：論理ページ番号. （例えば, 36 bit）
:::
このようにすることで, 論理ページと物理ページを対応させるときに, 
オフセットはそのままにして論理ページ番号と物理ページ番号（+ アクセス許可など補助情報）を対応させれば良い
→ あとは, **ページテーブル**を使う.

### ページテーブル
だいたい, 多段ページテーブルを使う. 上位ビットを分割して, それぞれのページテーブルを作って木構造にして参照する.
- 例：36bit を 9bit ずつに分割して, 4段のページテーブルを作る
    - 1段目：上位9bit で 検索 → 検索結果を利用して2段目のページテーブルへ移動 ……のくりかえし. 
    - それぞれの表で, PFN（物理ページ番号）の他に,W（書き込み可能ならば 1）, U（ユーザモードでアクセス可ならば 1）, 
    A（アクセスされたときに 1 が set される）, D（書き込まれたときに 1 が set される）, P（ページが存在するならば 1）などを持つ
    - 木構造にすることで, 使われていないビット部分の下位のページテーブルを作らなくても良い

### TLB (Translation Lookaside Buffer)
：キャッシュの一種. ページテーブルのアクセスを高速化するためのもの. 論理アドレス → (アクセス許可, 物理アドレス) の写像を一部保持している. 
ページテーブルだとメモリアクセスいっぱい必要だしね.

---
