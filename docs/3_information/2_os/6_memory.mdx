---
title: 6. メモリ管理
---

この章も重めです. アーキテクチャとも関連があります. これは**メモリ**内の話で, **二次記憶**はまた別！

## メモリとは
詳細は, アーキテクチャの記事も参照. 
- コンピュータには主記憶 (メインメモリ, 単にメモリ) が搭載されており, 典型的な大きさは, 4GB (ノート PC) ～ 256 GB (サーバ)
- CPU は**アドレス**を指定してメモリを読み書きする
- プログラムが使うデータはほぼ全てメモリの中にある
    - 本当に計算する時は, レジスタにロードしてきて計算する
    - メモリを使う手段：大域変数・配列, 局所変数・配列, ヒープ（例えば C だと）= アドレスに名前をつけただけ
:::warning[ポインタ]
C 言語などでは, ポインタを使ってメモリを扱うことが多い. ポインタはアドレスを格納する変数.
:::

---

## 論理アドレスと物理アドレス
:::tip[論理アドレスと物理アドレス]
- 論理（仮想, virtual!?）アドレス：プロセスがプロセスごとに使うアドレス. 1プロセスに1論理アドレス空間で, 同じ論理アドレスが全プロセスにある
- 物理アドレス：物理メモリを実際にアクセスするときのアドレス
:::
別にあったほうが何かと便利. 対応関係は後で取る.
- アドレスの範囲は物理メモリの量によらない. ソフト（OS）が決める
- アドレス変換はCPUが行う（論理アドレス $\rightarrow$ 物理アドレス）
- 論理アドレスに対応する物理アドレスがない場合もある（ページフォルト）
- **プロセスごとに論理アドレス空間が独立している**

---

## メモリ管理ユニット (MMU)
:::tip[MMU]
CPU 内のハードウェアで全メモリアクセスに介在し, **論理アドレス**に対して下記のことを行うハードウェア
1. アクセス権の検査（ユーザモードで読み出しできるのか, supervisorモードが必要なのかなど）
2. 対応する物理アドレスが存在するかの検査
3. 論理アドレスから物理アドレスへアクセス
:::
何かと便利な仮想メモリの管理をしているイメージ. 下記のような機能を持つ（MMUのメリットというか, 仮想アドレスのメリットというか）
- メモリ保護機能：プロセス間でメモリの分離 
- カーネル (OS) データの保護
- 物理メモリ量を越えたメモリ割り当て
- 要求時ページング (on demand paging): 物理メモリを確保せずに, メモリ割り当てを (高速に) 行える

--- 

## アドレス変換
詳細はアーキテクチャの記事も参照.
:::warning[目標]
**論理アドレスと物理アドレスの対応を取る！** = 論理アドレス $\rightarrow$ (アクセス許可, 物理アドレス) の写像を作りたい
:::

### ページ
:::tip[ページ]
論理アドレスで, 下位 A bit 以外が共通の $2^A$ 個のアドレスからなる領域のこと.
- ページサイズは $2^A$ byte（典型例は, $A = 12$, ページサイズ：4KB）
- 下位 A bit：ページ内オフセット
- それ以外の上位 bit：論理ページ番号. （例えば, 36 bit）
:::
このようにすることで, 論理ページと物理ページを対応させるときに, 
オフセットはそのままにして論理ページ番号と物理ページ番号（+ アクセス許可など補助情報）を対応させれば良い
$\rightarrow$ あとは, **ページテーブル**を使う.

### ページテーブル
だいたい, 多段ページテーブルを使う. 上位ビットを分割して, それぞれのページテーブルを作って木構造にして参照する.
- 例：36bit を 9bit ずつに分割して, 4段のページテーブルを作る
    - 1段目：上位9bit で 検索 $\rightarrow$ 検索結果を利用して2段目のページテーブルへ移動 ……のくりかえし. 
    - それぞれの表で, PFN（物理ページ番号）の他に,W（書き込み可能ならば 1）, U（ユーザモードでアクセス可ならば 1）, 
    A（アクセスされたときに 1 が set される）, D（書き込まれたときに 1 が set される）, P（ページが存在するならば 1）などを持つ
    - 木構造にすることで, 使われていないビット部分の下位のページテーブルを作らなくても良い

### TLB (Translation Lookaside Buffer)
：キャッシュの一種. ページテーブルのアクセスを高速化するためのもの. 論理アドレス $\rightarrow$ (アクセス許可, 物理アドレス) の写像を一部保持している. 
ページテーブルだとメモリアクセスいっぱい必要だしね.

---
## メモリ割り当て
ここでは, 仮想メモリの割り当てのことを行っている

:::note[Unixのメモリ割り当て API の例]
- `int e = brk(l);`：データ領域の終わりのアドレスを l にし, x < l のアドレス x が「利用可能」になる
    - データセグメントの終わりのアドレス = break 値と呼ぶ. なので, l は break 値
- `void * a = sbrk(sz);`：データ領域の終わりのアドレスを sz バイト増やし, 増やす前のアドレスを返す
    - $x\in[a, a+sz)$ のアドレスが利用可能に = break 値が a + sz になる
    - `sbrk(0)` = データセグメントの終わりのアドレス
- `mmap, mremap, munmap` ：より柔軟なメモリ割り当て・解放
- `int e = mprotect(a, sz, prot);` ：メモリのアクセス許可を設定
:::
### メモリ割り当ての動作例
1. `brk, sbrk, mmap` などでメモリを割り当てる = 所定の論理アドレスの範囲が「アクセス可能になる」
    - Segmentation Fault は, アクセス不可能なメモリにアクセスしようとしたら OS が返す
    - OS の管理するデータ（アドレス空間記述表 = `Linux mm_struct`：仮想メモリの状態）に, 割り当て済みと記述する. すぐには物理メモリを割り当てない
    - 実際にメモリアクセスされない場合はこのまま
2. CPU がメモリアクセス $\rightarrow$ ページフォルト例外を発生（論理アドレスしかないので）
3. OSの例外処理が発動（**マイナーフォルト**） $\rightarrow$ アクセスが合法かをアドレス空間記述表から確認して, 物理メモリを割り当てる（**要求時ページング**）
    - ページテーブルや TLB の更新も行う. **ページテーブルに記述 = 物理アドレスを割り当てる**
4. 物理メモリが逼迫したとき $\rightarrow$ ページング領域に退避して物理メモリを解放する（ページアウト, スワップアウト）
    - ページテーブルエントリ = 物理アドレス不在
    - **メジャーフォルト**：再びアクセスされたら, 二次記憶から内容を再び読み込む（時間がかかる）
5. 仮想メモリが解放された $\rightarrow$ OS は物理メモリを開放, ページテーブルエントリ = 物理アドレス不在

### ページ置換アルゴリズム
:::tip[ページ置換アルゴリズム]
どうやって物理メモリ上のページを二次記憶に退避させるか. ページアウト数を最小化したい
:::
#### 1. オフライン問題：将来のアクセス系列を全て入力とする（アクセス系列全部知ってる）
この時は, 常駐ページのうち, 次にアクセスされるまでの時間が最も長いページを置換するのが最適
#### 2. オンライン問題：将来のアクセスはわからない
最悪の場合, ページフォルト率 = 1. 最適なアルゴリズムは存在しないが, 以下のアルゴリズムがある
- LRU 置換：Least Recently Used (過去にアクセスされた時点が最も遠い) なページを置換
    - 必要なデータ構造が大変 $\rightarrow$ NRU (Not Recently Used) 置換を使う
- FIFO：最初にメモリに入れたページを置換（LRUで、2回目以降のアクセスを考えないバージョン）
- セカンドチャンス：FIFO であるが, 2回目以降のアクセスを保存しておき, アクセスがあればそのページを最後尾に移動させる
    - ある回数以内のアクセスしか記憶できない
- エイジング：物理メモリ上の各ページ $p$ が, 一定間隔の区間（世代）ごとの「アクセスあり・なし」を $N$ 世代分記録したカウンタ値 $H_p$ を持つ
    - 例えば, $H_p = 1010\cdots$：1世代前と3世代前にアクセスがあった


:::warning[注意]
- ページ置換は頻繁に起きてはならない（メモリが足りないことを意味するため）
    - **スラッシング**：ページ置換が頻繁に起きる状態
- 実際は, ページアウトは物理メモリが満杯になる前にページフォルトと非同期に行われる
    - OS が物理メモリを解放
    - ページテーブルエントリを物理アドレス不在に設定
    - ページアウトしたページを二次記憶に書き込み
        - ページアウトする際, ページインから変更していないページは書き込み不要
- ページアウトはまとめて行った方が IO 性能が良い
:::
---
## まとめ
:::tip[メモリ管理]
メモリ管理は, 論理アドレスと物理アドレスを組み合わせて賢く実装している
- メモリ管理ユニット（MMU）：ページテーブルを参照して論理アドレス $\rightarrow$ 物理アドレスの変換を行う
- ページ：論理アドレス空間を分割したもの
- ページテーブル：論理ページ番号 $\rightarrow$ 物理ページ番号の対応を取る
- TLB：論理ページ番号 $\rightarrow$ 物理ページ番号の対応を高速化するためのキャッシュ
- メモリ割り当て
    - 初回は要求時ページング：アクセスして初めて物理メモリを割り当てる
    - 物理メモリが逼迫したら, ページアウト
    - ページアウトアルゴリズム：LRU, FIFO, セカンドチャンス, エイジング…
:::

---
## その他
メモみたいなもの
### 資源使用量を知るAPI

- `int e = getrusage(RUSAGE SELF, ru);`：呼び出したプロセスの種々の資源使用量, イベント数を
`ru` に返す
    - マイナーフォルト, メジャーフォルト, 最大物理メモリ使用量 (RSS), CPU 仕様時間, etc
- `int e = getrusage(RUSAGE CHILDREN, ru);`：上記同様で子プロセスに対して

### 資源使用量を制限するAPI

- `int e = setrlimit(RLIMIT res, rl);`：呼び出したプロセスの資源 `res` の使用量を制限
- `int e = prlimit(pid, RLIMIT res, rl);`： `getrlimit, setrlimit` の機能をひとつに統合
- `cgroups`：上二つとは異なり, Linux で一部のプロセス (とその子孫) に対する資源割当量を制御する仕組み
    - コンテナ (Docker など) の基盤

### 物理メモリの割当状況を知るAPI

- `int e = mincore(addr, len, vec);` ： $[addr , addr + len)$ 内の各論理ページが物理メモリ上にある・ないを `vec` から始まる (char の) 配列に格納する
    - i ページ目が物理メモリにある $\rightarrow$ vec[i] == 1

### ページングを制御するAPI
- `int e = posix madvise(addr, length, adv);`
- `int e = madvise(addr, length, adv);`
    - 両者は似ているが後者は Linux 特有であり, 機能が多い
- adv に [addr, addr+length) の範囲のアクセスパターンを教える
    - `(POSIX_)MADV_NORMAL`
    - `(POSIX_)MADV_SEQUENTIAL` : 逐次的にアクセスする
    - `(POSIX_)MADV_RANDOM` : ランダムにアクセスする
    - `(POSIX_)MADV_WILLNEED` : 近い将来必要
    - `POSIX_MADV_DONTNEED` : 当分不要
    - `MADV_DONTNEED` : 不要 (値が失われても良い)
    - `MADV_COLD` : ページアウト候補対象に