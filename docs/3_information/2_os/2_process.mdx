---
title: 2. プロセス
---
## プロセスとは？
:::tip[基本用語]
- プログラム = 実行すべき命令が書かれているもの
    - Firefox, シェル (bash), ls, a.out, など
    - 実体としてはファイルとして存在している
- プロセス ≈ プログラムが走っているもの
    - メニューでアプリを起動するアイコンをクリックしたり, コマンドプロンプトに ls と打ち込むたびに, プロセスが作られている
:::

### プロセスの役割
:::tip[プロセスの役割]
**抽象化！！！** 各プロセスは独立に考えていいようにする！
:::
- 各プロセスは CPU のことを考えなくていい. 各プロセスはプロセスID(PID) で一意に識別される
    - PID 制御ってのを思い出した. 制御工学だけど
- 他のプロセスのメモリは読み書き不可

#### プロセスを観察したい場合（Unix CUI）
:::note[コマンド]
- ps : 基本 `ps auxww` ですべて. 大量に実行されているプロセスが出てくる
    - `ps auxww | grep ssh # ssh 走ってるか?`
    - `ps auxww | grep tau # ユーザ tau のプロセス`
- top : 時々刻々表示
- pstree : プロセスの親子関係も表示
- pgrep : 色々な基準でプロセスを検索 (≈ ps + grep)
:::
- Windows はタスクマネージャとか, Ubuntu は System Monitor とか, Linux は `/proc/pid` とか
- Unix についての[参考記事](https://qiita.com/minnsou/items/6b6b74fcd79bd00ace1a). イメージは, MacOS、Linuxの元となるOS. WindowsOSと対比される. CLI(CUI)なのが特徴？

---
## プロセスに関わるシステムコール（Unix）
### `fork`：プロセスを作る (コピーする)
- `fork()` の後, 続きが2 プロセス (親と子) で実行される
- 親と子で返り値だけが違う：（親: 子プロセスのプロセスID、子: 0）

```c
pid_t pid = fork(); // 以下、二つのプロセスが動く
if (pid == -1) {
    // 失敗 (子プロセスは作られていない)
} else if (pid == 0) { 
    // 子プロセス
} else {
    // 親プロセス
}
```
    
### `execve`：現プロセスで指定のプログラムを実行する
- 変種: `exec{v,l}p?e?` (引数の渡し方, 微妙な意味の違い)
- 以下, 総称して `exec` と呼ぶ (実際には exec という名前の関数はない)
- 呼び出したプロセスを, これまでのことをすべて忘れて所定のことをするプロセスに「変身させる」イメージ

```c
char * const argv[] = { "/bin/ls", "-l", 0 };
execv(argv[0], argv); // lsコマンドを実行
```

### `exit`：現プロセスを, 指定した終了ステータス(exit status) で終了させる
- main 関数が終了した場合も同じ効果 
    
```c[main.c]
exit(status);
```
    
### `waitpid`：子プロセスの終了待ち + 処理(ゾンビ状態を解消; プロセス番号の回収)
- 変種: wait, wait3, wait4
- プロセス C がゾンビ (defunct) = C が終了しているが,その親が (waitpid などで)C の終了を確認していない状態
= C のプロセス番号を再利用できない状態 「waitpid = “the parent reaps the child”」
    - `waitpid` は、子がプロセスを終了するまで待ち, プロセス番号を回収して処理を終える = 子プロセスがなくなる
    - 親が子より先に終了する $\rightarrow$ 全プロセスの先祖 (init) が C の親をする

```c
int ws;
pid_t pid = -1; /* -1 : どの子プロセスでも... pidで子プロセスを指定 */
int options = 0; /* 0 : 終了するまで待つ */
pid_t cid = waitpid(pid, &ws, options);
if (cid == -1) {
    // 失敗;
} else {
    // ... ws に, 子プロセスcid に何が起きたかの情報 ...
}
```

### 流れまとめ
:::tip[まとめ]
1. `fork` ：プロセスが複製される = 子プロセスの誕生
2. 親と子が両方続きを実行. そして, `exec`により, 現プロセスで指定したプログラム(`ls`など)を実行
    - exec を呼び出した続きは実行されない（指定したプログラムの main 関数を実行して終了するイメージ）
3. `exit`や`return` で子プロセスが終了 = ゾンビ状態
4. 親が `waitpid` で子プロセスの処理を行う（葬式）
:::