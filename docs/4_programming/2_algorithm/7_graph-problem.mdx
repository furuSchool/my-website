---
title: 7. グラフの諸問題
---
参照: [3. グラフとその探索 (BFS, DFS)](/docs/4_programming/3_algorithm/3_graph.mdx)

import CodeToggle from '/components/CodeToggle.tsx';

:::warning[目標]
グラフに関する様々な問題を解く。具体的には以下のようなもの。
- 最短経路問題
- 最小全域木問題
- 最大フロー問題
- 最小費用流問題
:::

---
## 2 頂点最短経路問題
:::warning[目標]
特定の 2 つのノード間の最短経路を求める。ある始点から他の全てのノードへの最短経路を求めることが多い。
:::
最短経路の部分経路も最短経路である，という性質を利用する。なお，各辺の距離 (重み) が全て同じなら，BFS で求めることができる。

### ダイクストラ法
:::tip[ダイクストラ法]
非負の重みを持つグラフにおいて，始点から繋がっているノードの最短距離を更新していくアルゴリズム。
1. 各ノードの最短距離を無限大に初期化。始点ノードは 0
2. 現在いるノードにつながるノードの最短距離の更新を試みる
3. 最短距離が最小のノードを選び，そのノードを現在のノードとする
4. 2, 3 を繰り返す
:::
- 計算量は $O(V^2 + E)$ であり，最短距離が最小のノードを選ぶのに $O(V)$ かかるのがボトルネック。$E$ は合計で全部の辺を 2 回ずつ見るため
- ノードのデータ構造としてヒープを使うことで $O((V + E) \log V)$ にできる。(実装したのは $O(E \log E)$)
    - 最短距離が最小のノードを選ぶこと，ヒープに追加することに $O(\log V)$ かかるため
    - フィボナッチヒープを使うと $O(E + V \log V)$ となる。これは，追加の計算量が $O(1)$ になるため
    - なお，$O(\log E) = O(\log V)$ である

<img src="/img/programming/dijkstra.png" alt="ダイクストラ法の結果例" width="50%"/>

<CodeToggle language="python" title="ダイクストラ法の実装">
```python
# 隣接リスト。[ノード, 距離]の形
edges_list = [
[[1, 5], [2, 4]], # ノードA
[[0, 5], [3, 3], [5, 9]], # ノードB
[[0, 4], [3, 2], [4, 3]], # ノードC
[[1, 3], [2, 2], [5, 1], [6, 7]], # ノードD
[[2, 3], [6, 8]], # ノードE
[[1, 9], [3, 1], [6, 2], [7, 5]], # ノードF
[[3, 7], [4, 8], [5, 2], [7, 2]], # ノードG
[[5, 5], [6, 2]] # ノードH
]

# Vはノードの数、e_listは隣接リスト
def dijkstra(V, e_list):
    inf = float('inf')
    done = [False]*V # ここを始点に計算したか (訪問済みか) 
    dist = [inf]*V # 始点からの距離
    dist[0] = 0
    while 1:
        tmp_min_dist = inf
        cur_node = -1
        for i in range(V): # 訪問済みでないノードで距離最小のノードを cur_node とする
            if (not done[i]) and (tmp_min_dist > dist[i]):
                tmp_min_dist = dist[i]
                cur_node = i
                
        for e in e_list[cur_node]: # cur_node から繋がっているノードの距離を更新
            if dist[e[0]] > dist[cur_node] + e[1]:
                dist[e[0]] = dist[cur_node] + e[1]
        done[cur_node] = True
                
        if cur_node == -1: break # すべてのノードを訪問したら終了
    return dist


import heapq
# ヒープを使う場合
# N:頂点, edges_list:隣接リスト, S:始点
def dijkstra_heap(N,edges_list,S):
    inf = float('inf')
    done = [False]*N
    dist = [inf]*N
    dist[S] = 0
    node_heap = [] 
    heapq.heappush(node_heap, [dist[S], S]) # ヒープに [距離, 始点] を追加

    while node_heap:
        tmp = heapq.heappop(node_heap) # 距離最小のノードを取り出す (計算量は O(log E))
        cur_node = tmp[1]
        if not done[cur_node]: # 未訪問なら
            for e in edges_list[cur_node]: # cur_node から繋がっているノードの距離を更新
                if dist[e[0]] > dist[cur_node] + e[1]:
                    dist[e[0]] = dist[cur_node] + e[1]
                    heapq.heappush(node_heap,[dist[e[0]], e[0]]) # 距離更新したならヒープに追加 (今回の計算量は O(log E))
            done[cur_node] = True
    return dist
```
</CodeToggle>

### ベルマン・フォード法
:::tip[ベルマン・フォード法]
負の重みを持つグラフにおいても最短経路を求めることができるアルゴリズム。負の閉路 (= 最短距離が無限に小さくできる) も検出できる。
1. 各ノードの最短距離を無限大に初期化。始点ノードは 0
2. 全ての辺を見て，各ノードの最短距離の更新を試みる。結果として，始点から徐々に距離が広がる
3. 2 を $V - 1$ 回繰り返す ($V$ はノードの数)。$V$ 回目に更新があった場合，負の閉路があると判断する
    - $V-1$ 回以内には最短距離が全体に広がってるはず ! (厳密には，始点から最も遠いノードまでの距離回数)
:::
- 計算量は $O(VE)$ であり，$V$ 回のループで全ての辺を見ている

<CodeToggle language="python" title="ベルマン・フォード法の実装">
```python
# [始点,終点,距離]
edges_list2 = [[0, 1, 5], [0, 2, 4], [1, 0, 5], [1, 3, 9], [1, 5, 9],
[2, 0, 4], [2, 3, 2], [2, 4, 3], [3, 1, 9], [3, 2, 2], [3, 5, 1],[3, 6, 7], 
[4, 2, 3], [4, 6, 8], [5, 1, 9], [5, 3, 1], [5, 6, 2],[5, 7, 5], [6, 3, 7], 
[6, 4, 8], [6, 5, 2], [6, 7, 2], [7, 5, 5], [7, 6, 2]]

def BellmanFord(V, e_list):
    inf = float('inf')
    dist = [inf]*V
    dist[0] = 0
    for j in range(V):
        for e in edges_list:
            if dist[e[1]] > e[2] + dist[e[0]]:
                dist[e[1]] = e[2] + dist[e[0]]
                if j==V-1: return -1 # 負の閉路がある
    return dist
```
</CodeToggle>

### SPFA (Shortest Path Faster Algorithm)
:::tip[SPFA]
ベルマン・フォード法の改良版で，毎回全ての辺をチェックすることを避けて高速化を図るアルゴリズム。
1. 各ノードの最短距離を無限大に初期化。始点ノードは 0
2. 始点ノードをキューに追加
3. キューからノードを取り出し，そのノードから繋がっているノードの距離を更新を試みる
4. 更新があったノードのみをキューに追加する
5. キューが空になるまで 3, 4 を繰り返す
6. 同じノードがキューに $V$ 回追加された場合，負の閉路があると判断する
:::
- 計算量は最悪の場合 $O(VE)$ だが，平均的には $O(E)$ に近い

<CodeToggle language="python" title="SPFA の実装">
```python
# 隣接リスト。[ノード, 距離]の形
edges_list = [
[[1, 5], [2, 4]], # ノードA
[[0, 5], [3, 3], [5, 9]], # ノードB
[[0, 4], [3, 2], [4, 3]], # ノードC
[[1, 3], [2, 2], [5, 1], [6, 7]], # ノードD
[[2, 3], [6, 8]], # ノードE
[[1, 9], [3, 1], [6, 2], [7, 5]], # ノードF
[[3, 7], [4, 8], [5, 2], [7, 2]], # ノードG
[[5, 5], [6, 2]] # ノードH
]

from collections import deque
# 引数：ノード数、隣接リスト
def spfa(V, e_list):
    inf = float('inf')
    dist = [inf]*V
    dist[0] = 0
    node_to_check = deque()
    in_queue = [False]*V
    node_to_check.append(0)
    in_queue[0] = True
    while node_to_check:
        cur_node = node_to_check.popleft() # キューからノードを取り出す
        in_queue[cur_node] = False
        for e in e_list[cur_node]: # cur_node から繋がっているノードの距離を更新
            if dist[e[0]] > dist[cur_node] + e[1]:
                dist[e[0]] = dist[cur_node] + e[1]
                if not in_queue[e[0]]: # 更新があったが、キューにまだ入っていないノードを追加
                    in_queue[e[0]] = True
                    node_to_check.append(e[0])
    return dist
```
</CodeToggle>

---
## 全点対最短経路問題
:::warning[目標]
全ての 2 ノード間の最短経路を求める。
:::
### ワーシャル・フロイド法
:::tip[ワーシャル・フロイド法]
全てのノード間の最短距離を求めるアルゴリズム。DP を用いて，最短距離を更新していく。
- 任意のノード $i$ から $j$ への最短距離について，ノード $k$ を経由する場合の最短距離を考えて更新を試みる
    - 具体的には，$d[i][j] = \min(d[i][j], d[i][k] + d[k][j])$ を $k = 0, 1, \ldots, V - 1$ の順に全てのノードについて行う
:::
- 計算量は $O(V^3)$。ダイクストラ法を全ての始点で適用すると，$O(VE \log V)$ となる

<CodeToggle language="python" title="ワーシャル・フロイド法の実装">
```python
inf = float('inf')
e_matrix = [
[0, 5, 4, inf, inf, inf, inf, inf], # ノードA
[5, 0, inf, 3, inf, 9, inf, inf], # ノードB
[4, inf, 0, 2, 3, inf, inf, inf], # ノードC
[inf, 3, 2, 0, inf, 1, 7, inf], # ノードD
[inf, inf, 3, inf, 0, inf, 8, inf], # ノードE
[inf, 9, inf, 1, inf, 0, 2, 5], # ノードF
[inf, inf, inf, 7, 8, 2, 0, 2], # ノードG
[inf, inf, inf, inf, inf, 5, 2, 0] # ノードH
]

# 引数：ノードの総数、隣接⾏列
def WarshallFloyd(V, e_matrix):
    # dist[i][j]：隣接行列を更新する形で、ノードiからノードjまで最短距離を保持する
    dist = e_matrix 
    for k in range(V):
        for i in range(V):
            for j in range(V):
                if dist[i][k] != inf and dist[k][j] != inf:
                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])
    return dist
```
</CodeToggle>

---
## 最小全域木問題
:::warning[目標]
最小全域木 (MST) を求める。すなわち，グラフの全てのノードが連結されているツリーで，辺の重みの合計が最小になるものを求める。
:::

### Union-Find 木
:::tip[Union-Find 木]
要素を複数の木に分けて管理するデータ構造。各木に対して，Union (結合) と Find (探索) の操作を行える。
- Unite (結合) : 片方の木の根からもう片方の木の根に繋ぐ
- Find (探索) : 要素がどの木に属しているかを調べる。すなわち，その要素の根を見つける
- 互いの木の要素は重ならない (素集合)
:::

<CodeToggle language="python" title="Union-Find 木の実装">
```python
class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)] # 初期化（全員独立）
        self.height = [0 for _ in range(n)] # 各⽊の⾼さ
        
    def get_root(self, i): # 要素 i の根ノードを探す
        if self.parent[i] == i: return i
        else:
            self.parent[i] = self.get_root(self.parent[i]) # 再帰的に根を探し、要素 i の親をその根に更新する (経路圧縮)
            return self.parent[i]
            
    def unite(self, i, j): # 要素 i と j の属する木を結合する
        root_i = self.get_root(i)
        root_j = self.get_root(j)
        if root_i != root_j: 
            if self.height[root_i] < self.height[root_j]:
                self.parent[root_i] = root_j # 要素 i の根を要素 j の根に繋ぐ
            else:
                self.parent[root_j] = root_i # 要素 j の根を要素 i の根に繋ぐ
                if self.height[root_i] == self.height[root_j]:
                    self.height[root_i] += 1 # 二つの木の高さが同じ時のみ、結合後の高さが 1 増える
```
</CodeToggle>


### クリスカル法 (Kruskal's algorithm)
:::tip[クリスカル法]
辺の距離 (重み) が小さい順に辺を選んでいき，サイクルができないようにすることで最小全域木を求める。
1. 全ての辺を距離の小さい順にソートする
2. ソートした辺を順に見ていき，サイクルができない場合，最小全域木に追加する
3. 全ての辺のチェックが終わるまで 2 を繰り返す
:::
- 全体の計算量は，Union-Find 木を使う場合，隣接リストなら $O(E \log E)$，隣接行列なら辺を取り出すために $O(V^2)$ となる

ここで，閉路の検出方法が重要となる。
- 閉路の検出として，辺を足す前に BFS や DFS を行って，繋ごうとしてるノードがすでに繋がっているかを確認することも可能。この場合，計算量は $O(V^2)$
    - 一回の BFS や DFS は $O(E +V) = O(V)$ であり，これを $V = 1,2,…$ で行うため
- Union-Find 木を使うと，閉路の検出自体はほとんど $O(1)$ で行える
    - ここでは，ノード間を辺で繋いだ時に二つのノードの属する木を結合することで，すでに 2 ノードが結合されている場合は辺を追加しないようにする

<CodeToggle language="python" title="クリスカル法の実装">
```python
# [始点, 終点, 距離] のリスト
e_list = [
[0, 1, 5], [0, 2, 4], [1, 3, 3], [1, 5, 9],
[2, 3, 2], [2, 4, 3], [3, 5, 1], [3, 6, 7],
[4, 6, 8], [5, 6, 2], [5, 7, 5], [6, 7, 2]
]

def kruskal(V, e_list):
    e_cost_sorted = sorted(e_list) # 辺を距離の小さい順にソート
    uf_tree = UnionFind(V)
    mst = []
    for item in e_cost_sorted:
        if uf_tree.get_root(item[1]) != uf_tree.get_root(item[2]): # 2 ノードが異なる木に属す
            uf_tree.unite(item[1], item[2]) # 2 ノードを結合
            mst.append([item[0], item[1], item[2]]) # 最小全域木に追加
    return mst
```
</CodeToggle>

### プリム法 (Prim's algorithm)
:::tip[プリム法]
始点から繋がっているノードの中で，最小の距離を持つ辺を選び，そのノードを最小全域木に追加していくアルゴリズム。
1. 始点ノードを最小全域木に追加
2. 最小全域木に追加したノードから繋がっているノードの中で，最小の距離を持つ辺を選んでそのノードを最小全域木に追加する
3. 2 を全てのノードが最小全域木に追加されるまで繰り返す
:::

- 計算量 : 隣接行列で最小距離の辺をナイーブに選ぶと，$O(V^3)$。隣接リストで最小距離の辺をナイーブに選ぶと $O(EV)$
- ヒープを用いた下記の実装では $O(E\log E)$。フィボナッチヒープを用いると $O(E + V \log V)$ となる

<CodeToggle language="python" title="プリム法の実装">
```python
import heapq

# [距離, 始点, 終点] のリスト
e_list = [
[5, 0, 1], [4, 0, 2], [3, 1, 3], [9, 1, 5],
[2, 2, 3], [3, 2, 4], [1, 3, 5], [7, 3, 6],
[8, 4, 6], [2, 5, 6], [5, 5, 7], [2, 6, 7]
]

def prim(V, e_list):
    edges_from = [[] for _ in range(V)] 
    for e in e_list: # 隣接リストに変換
        edges_from[e[1]].append([e[0], e[1], e[2]]) # [距離, 始点, 終点] の形
    e_heapq = []
    mst = [] # 最⼩全域⽊
    included = [False]*V
    included[0] = True
    for e in edges_from[0]: # 始点から伸びる全ての辺をヒープに追加
        heapq.heappush(e_heapq, e)
    while len(e_heapq):
        min_edge = heapq.heappop(e_heapq) # 最小距離の辺を取り出す
        if not included[min_edge[2]]:
            included[min_edge[2]] = True
            mst.append([min_edge[1], min_edge[2]]) # 最小全域木に辺を追加
            for e in edges_from[min_edge[2]]: # 取り出した辺の終点から伸びる辺をヒープに追加 (追加前のもののみ)
                if not included[e[2]]:
                    heapq.heappush(e_heapq, e) 
    return mst
```
</CodeToggle>

---
## トポロジカルソート
:::warning[目標]
閉路のない有向グラフにおいて，全ての有向辺の向きが同じになるように並び替える。結果は複数存在する可能性がある。

また，そのような並び替えをできるグラフを **有向非巡回グラフ (DAG)** と呼ぶ。
- DAG は巡回できる閉路が存在しない。ただし，木でない場合もある
:::
- 有向木 : DAG の一種であり，根を一つだけもち，辺の向きが根から葉，もしくは葉から根のどちらかに限られる。
また，任意の 2 ノード間に一意のパスが存在する (これは木の条件)
- 以下の図は DAG の例
    <div style={{ display: 'flex', justifyContent: 'left', gap: '20px', flexWrap: 'wrap', marginBottom: '40px' }}>
    <img src="/img/programming/dag1.png" alt="DAG の例" style={{ width: '20%', aspectRatio: 'auto', objectFit: 'contain' }} />
    <img src="/img/programming/dag2.png" alt="DAG の例" style={{ width: '40%', aspectRatio: 'auto', objectFit: 'contain' }} />
    </div>

### Kahn のトポロジカルソート (Kahn's algorithm)
:::tip[Kahn のトポロジカルソート]
入次数 0 のノードを見つけ出し，グラフから順次取り出していく。もし，途中で入次数 0 のノードがなくなった場合，DAG ではないと判断する。
:::
- 計算量は $O(V + E)$

<CodeToggle language="python" title="Kahn のトポロジカルソートの実装">
```python
# 隣接リスト。[始点, 終点] の形
edges = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 4], [3, 4]]
from collections import deque

# 引数：V:ノード数, E:辺の数, edges:隣接リスト
def KahnTopo(V, E, edges):
    indeg = [0]*V
    outedge = [[] for _ in range (V)] # 各ノードから伸びる辺の [終点] の隣接リスト
    for v_from, v_to in edges: # 入次数と辺のリストを作成
        indeg[v_to] += 1
        outedge[v_from].append(v_to) 
        
    sorted_g = []
    deq = deque([i for i in range(V) if indegree[i] == 0])
    while deq:
        v = deq.popleft() # 入次数 0 のノードを取り出す
        for item in outedge[v]:
            inedge[item] -= 1  # 取り出したノードとつながるノードの入次数を減らす
            E -= 1 # 辺の数を減らす
            if inedge[item] == 0: # 入次数が 0 になったノードを deq に追加
                deq.append(item)
        sorted_g.append(v)
    if len(sorted_nodes) == V:
        return sorted_nodes
    else:
        return None # DAG ではない
```
</CodeToggle>

### Tarjan のトポロジカルソート (Tarjan's algorithm)
:::tip[Tarjan のトポロジカルソート]
DFS を用いて，先に進めないノードまで到達したら，そこから戻りながらノードを取り出していく。
もし，途中で同じノードに戻ってきた場合，DAG ではないと判断する。
:::

- 計算量は $O(V + E)$

<CodeToggle language="python" title="Tarjan のトポロジカルソートの実装">
```python
def TarjanTopo(V, edges):
    def check(v):
        if visited[v] == 1:
            return None # 2回目の訪問なら DAG ではない
        elif visited[v] == 0:
            visited[v] = 1 # 処理待ちにする
            for to_v in outedge[v]: check(to_v) # 隣接ノードを再帰
            # 自分より深いノードが処理済みになれば、次は自分が処理済みになって呼び出される
            visited[v] = 2
            sorted_g.appendleft(v)
        
    visited = [0]*V # 0: 未訪問, 1: 処理待ち, 2: 処理済
    outedge = [[] for _ in range (V)]
    for e in edges: outedge[e[0]].append(e[1]) # 各ノードから伸びる辺の [終点] の隣接リスト
    sorted_g = deque()
    for i in range(V): check(i) # 各ノードをチェック
    return sorted_g
```
</CodeToggle>

### トポロジカルソートの応用例
- 閉路チェック : 有向グラフにおいてトポロジカルソートできなかった場合，どこかに閉路が存在する（有向巡回グラフになっている）
- プロジェクトの依存関係を考慮したスケジューリング
- DAG における最短経路を求める
    - 計算量は $O(V + E)$ でいける

<CodeToggle language="python" title="DAG における最短経路を求める">
```python
def shortest_path_DAG(V, E, edges, start_vertex):
    sorted_g = KahnTopo(V, E, edges) # トポロジカルソートを行う
    if not sorted_g:
        return None # DAG でない場合は None を返す
    edge_list = [[] for _ in range(V)]
    for u, v, weight in edges:
        edge_list[u].append([v, weight]) # 各ノードから伸びる辺の [終点, 重み] の隣接リスト
    dist = [float('inf')] * V; dist[start_vertex] = 0 # start_vertex からの距離を初期化
    
    for u in sorted_g:
        if dist[u] != float('inf'):
            for v, weight in edge_list[u]: # u からつながる全てのノード v の距離を更新
                if dist[v] > dist[u] + weight:
                    dist[v] = dist[u] + weight
    return dist
```
</CodeToggle>